<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>[xv6 學習紀錄 08] Lab: locks | Yama&#39;s Trail</title>
<meta name="keywords" content="">
<meta name="description" content="Lab 連結：Lab: locks
Memory allocator (moderate)

Your job is to implement per-CPU freelists, and stealing when a CPU&rsquo;s free list is empty. You must give all of your locks names that start with &ldquo;kmem&rdquo;. That is, you should call initlock for each of your locks, and pass a name that starts with &ldquo;kmem&rdquo;. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run usertests sbrkmuch. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in usertests -q pass. make grade should say that the kalloctests pass.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/xv6/lab8/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e1f5c4cae44599655f7ff95195ff89c8cb3adbda94f2b1581a434ab2b4d4e6cf.css" integrity="sha256-4fXEyuRFmWVff/lRlf&#43;JyMs629qU8rFYGkNKsrTU5s8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon_io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon_io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon_io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon_io/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/xv6/lab8/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Yama&#39;s Trail (Alt + H)">Yama&#39;s Trail</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/dev-log/" title="這個網站的誕生">
                    <span>這個網站的誕生</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/leetcode/" title="LeetCode 解題">
                    <span>LeetCode 解題</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/xv6/" title="xv6 學習紀錄">
                    <span>xv6 學習紀錄</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [xv6 學習紀錄 08] Lab: locks
    </h1>
    <div class="post-meta"><span title='2025-10-23 14:41:29 +0800 CST'>October 23, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>Lab 連結：<a href="https://pdos.csail.mit.edu/6.S081/2022/labs/lock.html">Lab: locks</a></p>
<h2 id="memory-allocator-moderate">Memory allocator (moderate)<a hidden class="anchor" aria-hidden="true" href="#memory-allocator-moderate">#</a></h2>
<blockquote>
<p>Your job is to implement per-CPU freelists, and stealing when a CPU&rsquo;s free list is empty. You must give all of your locks names that start with &ldquo;kmem&rdquo;. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with &ldquo;kmem&rdquo;. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests</code> <code>sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests -q</code> pass. make grade should say that the <code>kalloctests</code> pass.</p></blockquote>
<h3 id="做出-per-cpu-freelists">做出 per-CPU freelists<a hidden class="anchor" aria-hidden="true" href="#做出-per-cpu-freelists">#</a></h3>
<blockquote>
<p>You can use the constant <code>NCPU</code> from <code>kernel/param.h</code></p></blockquote>
<p>把原先的 <code>kmem</code> 變成一個 array，題目說大小可以直接用 <code>NCPU</code> 的 8 個 CPU</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>freelist;
</span></span><span style="display:flex;"><span>} kmem[NCPU];
</span></span></code></pre></div><blockquote>
<p>Let <code>freerange</code> give all free memory to the CPU running <code>freerange</code>.</p></blockquote>
<p>這裡的意思也就是 CPU 0 在初始的過程中會拿到所有的 memory，這裡要想到的問題是 CPU 1 ~ CPU 7 在初始過後沒有拿到任何的 memory
這在之後 steal 的機制會說明
<code>freerange</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kinit</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>kmem[i].lock, <span style="color:#e6db74">&#34;kmem&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">freerange</span>(end, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)PHYSTOP);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>kfree()</code> 與 <code>kalloc()</code> 變成了都只針對</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pa)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(((uint64)pa <span style="color:#f92672">%</span> PGSIZE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)pa <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">||</span> (uint64)pa <span style="color:#f92672">&gt;=</span> PHYSTOP)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;kfree&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Fill with junk to catch dangling refs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">memset</span>(pa, <span style="color:#ae81ff">1</span>, PGSIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run<span style="color:#f92672">*</span>)pa;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 這裡變成都是針對當前 CPU 的 freelist 進行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  kmem[id].freelist <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 這裡變成都是針對當前 CPU 的 freelist 進行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(r)
</span></span><span style="display:flex;"><span>    kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(r)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="steal-的機制">steal 的機制<a hidden class="anchor" aria-hidden="true" href="#steal-的機制">#</a></h3>
<p>如同先前所說，在 <code>freerange()</code> 的初始之後，CPU 1 會拿到所有的 memory，試想現在 CPU 1 想要 <code>kalloc()</code> 一個 page，雖然 CPU 0 還有很多 memory 可以用，但是 CPU 1 還是會拿不到任何的 memory，這時候我們可以</p>
<ol>
<li>steal CPU 0 的所有 page</li>
<li>steal CPU 0 的一個 page</li>
</ol>
<p>這兩個方法都是可行的想法，但是沒有幫助到最一開始的目的，這裡我用的是，<code>kalloc()</code> 發現沒有 memory 可以用的時候</p>
<ul>
<li>steal CPU 0 的 page 數量的一半</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> victim;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>slow;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>prevslow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>fast;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (r) {
</span></span><span style="display:flex;"><span>    kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (victim <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; victim <span style="color:#f92672">&lt;</span> NCPU; victim<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">==</span> id)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (kmem[victim].freelist) {
</span></span><span style="display:flex;"><span>      fast <span style="color:#f92672">=</span> slow <span style="color:#f92672">=</span> kmem[victim].freelist;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        prevslow <span style="color:#f92672">=</span> slow;
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prevslow) {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> kmem[victim].freelist;
</span></span><span style="display:flex;"><span>        kmem[victim].freelist <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> slow;
</span></span><span style="display:flex;"><span>        prevslow<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>      kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>實做過程中間覺得 <code>acquire()</code> 跟 <code>release()</code> 的時機真的需要想清楚，尤其是不同的分支都要顧慮到，不然還蠻容易漏掉的。</p>
<h2 id="buffer-cache-hard">Buffer cache (hard)<a hidden class="anchor" aria-hidden="true" href="#buffer-cache-hard">#</a></h2>
<blockquote>
<p>If multiple processes use the file system intensively, they will likely contend for <code>bcache.lock</code>, which protects the disk block cache in <code>kernel/bio.c</code>. <code>bcachetest</code> creates several processes that repeatedly read different files in order to generate contention on <code>bcache.lock</code>; its output looks like this (before you complete this lab):</p></blockquote>
<p>這裡的情況是說假設有很多的 process 在使用 file system 這時候的 <code>bcache.lock</code> (用來保護 disk block 的 lock) 會被激烈的被搶奪，<code>bcachetest</code> 製造了這個 <code>bcache.lock</code> 的 contention 的情形</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ bcachetest
</span></span><span style="display:flex;"><span>start test0
</span></span><span style="display:flex;"><span>test0 results:
</span></span><span style="display:flex;"><span>--- lock kmem/bcache stats
</span></span><span style="display:flex;"><span>lock: kmem: <span style="color:#75715e">#test-and-set 0 #acquire() 33035</span>
</span></span><span style="display:flex;"><span>lock: bcache: <span style="color:#75715e">#test-and-set 16142 #acquire() 65978</span>
</span></span><span style="display:flex;"><span>--- top <span style="color:#ae81ff">5</span> contended locks:
</span></span><span style="display:flex;"><span>lock: virtio_disk: <span style="color:#75715e">#test-and-set 162870 #acquire() 1188</span>
</span></span><span style="display:flex;"><span>lock: proc: <span style="color:#75715e">#test-and-set 51936 #acquire() 73732</span>
</span></span><span style="display:flex;"><span>lock: bcache: <span style="color:#75715e">#test-and-set 16142 #acquire() 65978</span>
</span></span><span style="display:flex;"><span>lock: uart: <span style="color:#75715e">#test-and-set 7505 #acquire() 117</span>
</span></span><span style="display:flex;"><span>lock: proc: <span style="color:#75715e">#test-and-set 6937 #acquire() 73420</span>
</span></span><span style="display:flex;"><span>tot<span style="color:#f92672">=</span> <span style="color:#ae81ff">16142</span>
</span></span><span style="display:flex;"><span>test0: FAIL
</span></span><span style="display:flex;"><span>start test1
</span></span><span style="display:flex;"><span>test1 OK
</span></span></code></pre></div><p>這裡要注意的是 <code>bcache.lock</code> 的 contention 過高</p>
<blockquote>
<p>Modify the block cache so that the number of <code>acquire</code> loop iterations for all locks in the <code>bcache</code> is close to zero when running bcachetest. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it&rsquo;s OK if the sum is less than 500. Modify bget and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don&rsquo;t all have to wait for <code>bcache.lock</code>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure <code>usertests -q</code> still passes. make grade should pass all tests when you are done.</p></blockquote>
<p>題目要我們更改</p>
<p>我猜根據 lock 多，可以獲得較多 concurrency 的原則，應該是可以透過增加 lock 來減少 contention 的數量</p>
<blockquote>
<ul>
<li>Read the description of the block cache in the xv6 book (Section 8.1-8.3).</li>
</ul></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/xv6/bcache/">
    <span class="title">« Prev</span>
    <br>
    <span>[xv6 學習紀錄 08-3] bcache 相關程式碼解析</span>
  </a>
  <a class="next" href="http://localhost:1313/dev-log/notes/">
    <span class="title">Next »</span>
    <br>
    <span>[這個網站的誕生] 筆記區域</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Yama&#39;s Trail</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
