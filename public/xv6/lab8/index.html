<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>[xv6 學習紀錄 08] Lab: locks | Yama&#39;s Trail</title>
<meta name="keywords" content="">
<meta name="description" content="Lab 連結：Lab: locks
Memory allocator (moderate)

Your job is to implement per-CPU freelists, and stealing when a CPU&rsquo;s free list is empty. You must give all of your locks names that start with &ldquo;kmem&rdquo;. That is, you should call initlock for each of your locks, and pass a name that starts with &ldquo;kmem&rdquo;. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run usertests sbrkmuch. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in usertests -q pass. make grade should say that the kalloctests pass.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/xv6/lab8/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e1f5c4cae44599655f7ff95195ff89c8cb3adbda94f2b1581a434ab2b4d4e6cf.css" integrity="sha256-4fXEyuRFmWVff/lRlf&#43;JyMs629qU8rFYGkNKsrTU5s8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon_io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon_io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon_io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon_io/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/xv6/lab8/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Yama&#39;s Trail (Alt + H)">Yama&#39;s Trail</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/dev-log/" title="這個網站的誕生">
                    <span>這個網站的誕生</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/leetcode/" title="LeetCode 解題">
                    <span>LeetCode 解題</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/xv6/" title="xv6 學習紀錄">
                    <span>xv6 學習紀錄</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [xv6 學習紀錄 08] Lab: locks
    </h1>
    <div class="post-meta"><span title='2025-10-23 14:41:29 +0800 CST'>October 23, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>Lab 連結：<a href="https://pdos.csail.mit.edu/6.S081/2022/labs/lock.html">Lab: locks</a></p>
<h2 id="memory-allocator-moderate">Memory allocator (moderate)<a hidden class="anchor" aria-hidden="true" href="#memory-allocator-moderate">#</a></h2>
<blockquote>
<p>Your job is to implement per-CPU freelists, and stealing when a CPU&rsquo;s free list is empty. You must give all of your locks names that start with &ldquo;kmem&rdquo;. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with &ldquo;kmem&rdquo;. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests</code> <code>sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests -q</code> pass. make grade should say that the <code>kalloctests</code> pass.</p></blockquote>
<h3 id="做出-per-cpu-freelists">做出 per-CPU freelists<a hidden class="anchor" aria-hidden="true" href="#做出-per-cpu-freelists">#</a></h3>
<blockquote>
<p>You can use the constant <code>NCPU</code> from <code>kernel/param.h</code></p></blockquote>
<p>把原先的 <code>kmem</code> 變成一個 array，題目說大小可以直接用 <code>NCPU</code> 的 8 個 CPU</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>freelist;
</span></span><span style="display:flex;"><span>} kmem[NCPU];
</span></span></code></pre></div><blockquote>
<p>Let <code>freerange</code> give all free memory to the CPU running <code>freerange</code>.</p></blockquote>
<p>這裡的意思也就是 CPU 0 在初始的過程中會拿到所有的 memory，這裡要想到的問題是 CPU 1 ~ CPU 7 在初始過後沒有拿到任何的 memory
這在之後 steal 的機制會說明
<code>freerange</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kinit</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>kmem[i].lock, <span style="color:#e6db74">&#34;kmem&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">freerange</span>(end, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)PHYSTOP);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>kfree()</code> 與 <code>kalloc()</code> 變成了都只針對</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pa)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(((uint64)pa <span style="color:#f92672">%</span> PGSIZE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)pa <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">||</span> (uint64)pa <span style="color:#f92672">&gt;=</span> PHYSTOP)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;kfree&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Fill with junk to catch dangling refs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">memset</span>(pa, <span style="color:#ae81ff">1</span>, PGSIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run<span style="color:#f92672">*</span>)pa;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 這裡變成都是針對當前 CPU 的 freelist 進行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  kmem[id].freelist <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 這裡變成都是針對當前 CPU 的 freelist 進行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(r)
</span></span><span style="display:flex;"><span>    kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(r)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="steal-的機制">steal 的機制<a hidden class="anchor" aria-hidden="true" href="#steal-的機制">#</a></h3>
<p>如同先前所說，在 <code>freerange()</code> 的初始之後，CPU 1 會拿到所有的 memory，試想現在 CPU 1 想要 <code>kalloc()</code> 一個 page，雖然 CPU 0 還有很多 memory 可以用，但是 CPU 1 還是會拿不到任何的 memory，這時候我們可以</p>
<ol>
<li>steal CPU 0 的所有 page</li>
<li>steal CPU 0 的一個 page</li>
</ol>
<p>這兩個方法都是可行的想法，但是沒有幫助到最一開始的目的，這裡我用的是，<code>kalloc()</code> 發現沒有 memory 可以用的時候</p>
<ul>
<li>steal CPU 0 的 page 數量的一半</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> victim;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>slow;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>prevslow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>fast;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">push_off</span>();
</span></span><span style="display:flex;"><span>  id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> kmem[id].freelist;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (r) {
</span></span><span style="display:flex;"><span>    kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (victim <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; victim <span style="color:#f92672">&lt;</span> NCPU; victim<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">==</span> id)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (kmem[victim].freelist) {
</span></span><span style="display:flex;"><span>      fast <span style="color:#f92672">=</span> slow <span style="color:#f92672">=</span> kmem[victim].freelist;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        prevslow <span style="color:#f92672">=</span> slow;
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prevslow) {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> kmem[victim].freelist;
</span></span><span style="display:flex;"><span>        kmem[victim].freelist <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> slow;
</span></span><span style="display:flex;"><span>        prevslow<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>      kmem[id].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[id].lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem[victim].lock);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>實做過程中間覺得 <code>acquire()</code> 跟 <code>release()</code> 的時機真的需要想清楚，尤其是不同的分支都要顧慮到，不然還蠻容易漏掉的。</p>
<h2 id="buffer-cache-hard">Buffer cache (hard)<a hidden class="anchor" aria-hidden="true" href="#buffer-cache-hard">#</a></h2>
<blockquote>
<p>If multiple processes use the file system intensively, they will likely contend for <code>bcache.lock</code>, which protects the disk block cache in <code>kernel/bio.c</code>. <code>bcachetest</code> creates several processes that repeatedly read different files in order to generate contention on <code>bcache.lock</code>; its output looks like this (before you complete this lab):</p></blockquote>
<p>這裡的情況是說假設有很多的 process 在使用 file system 這時候的 <code>bcache.lock</code> (用來保護 disk block 的 lock) 會被激烈的被搶奪，<code>bcachetest</code> 製造了這個 <code>bcache.lock</code> 的 contention 的情形</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ bcachetest
</span></span><span style="display:flex;"><span>start test0
</span></span><span style="display:flex;"><span>test0 results:
</span></span><span style="display:flex;"><span>--- lock kmem/bcache stats
</span></span><span style="display:flex;"><span>lock: kmem: <span style="color:#75715e">#test-and-set 0 #acquire() 33035</span>
</span></span><span style="display:flex;"><span>lock: bcache: <span style="color:#75715e">#test-and-set 16142 #acquire() 65978</span>
</span></span><span style="display:flex;"><span>--- top <span style="color:#ae81ff">5</span> contended locks:
</span></span><span style="display:flex;"><span>lock: virtio_disk: <span style="color:#75715e">#test-and-set 162870 #acquire() 1188</span>
</span></span><span style="display:flex;"><span>lock: proc: <span style="color:#75715e">#test-and-set 51936 #acquire() 73732</span>
</span></span><span style="display:flex;"><span>lock: bcache: <span style="color:#75715e">#test-and-set 16142 #acquire() 65978</span>
</span></span><span style="display:flex;"><span>lock: uart: <span style="color:#75715e">#test-and-set 7505 #acquire() 117</span>
</span></span><span style="display:flex;"><span>lock: proc: <span style="color:#75715e">#test-and-set 6937 #acquire() 73420</span>
</span></span><span style="display:flex;"><span>tot<span style="color:#f92672">=</span> <span style="color:#ae81ff">16142</span>
</span></span><span style="display:flex;"><span>test0: FAIL
</span></span><span style="display:flex;"><span>start test1
</span></span><span style="display:flex;"><span>test1 OK
</span></span></code></pre></div><p>這裡要注意的是 <code>bcache.lock</code> 的 contention 過高</p>
<blockquote>
<p>Modify the block cache so that the number of <code>acquire</code> loop iterations for all locks in the <code>bcache</code> is close to zero when running <code>bcachetest</code>. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it&rsquo;s OK if the sum is less than 500. Modify bget and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don&rsquo;t all have to wait for <code>bcache.lock</code>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure <code>usertests -q</code> still passes. make grade should pass all tests when you are done.</p></blockquote>
<p>題目要我們更改</p>
<p>我猜根據 lock 多，可以獲得較多 concurrency 的原則，應該是可以透過增加 lock 來減少 contention 的數量</p>
<blockquote>
<ul>
<li>Read the description of the block cache in the xv6 book (Section 8.1-8.3).</li>
</ul></blockquote>
<p><a href="../bcache">[xv6 學習紀錄 08-3] bcache 相關程式碼解析</a></p>
<blockquote>
<ul>
<li>It is OK to use a fixed number of buckets and not resize the hash table dynamically. Use a prime number of buckets (e.g., 13) to reduce the likelihood of hashing conflicts.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Searching in the hash table for a buffer and allocating an entry for that buffer when the buffer is not found must be atomic.</li>
</ul></blockquote>
<p>我原本還想說要每一個 buf 都用一個 lock，但這兩個 hint 應該是說用一個 hash table 來處理</p>
<blockquote>
<ul>
<li>Remove the list of all buffers (<code>bcache.head</code> etc.) and don&rsquo;t implement LRU. With this change <code>brelse</code> doesn&rsquo;t need to acquire the bcache lock. In <code>bget</code> you can select any block that has <code>refcnt == 0</code> instead of the least-recently used one.</li>
</ul></blockquote>
<p>這裡在說不需要實做 LRU 了，包含先前用的 <code>bcache.head</code> 也不必使用了。</p>
<ul>
<li><code>brelse()</code> 也不需要 acquire <code>bcache.lock</code> 這可以減少 contention</li>
<li>原本的 <code>bget()</code> 會去尋找 least-recently used 的 buf，現在直接隨便尋找一個 <code>refcnt==0</code> 的 buf 就可以了</li>
</ul>
<blockquote>
<ul>
<li>You probably won&rsquo;t be able to atomically check for a cached buf and (if not cached) find an unused buf; you will likely have to drop all locks and start from scratch if the buffer isn&rsquo;t in the cache. It is OK to serialize finding an unused buf in bget (i.e., the part of bget that selects a buffer to re-use when a lookup misses in the cache).</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</li>
</ul></blockquote>
<p>這裡需要兩個 lock，也蠻有可能跟 Memory allocator 那一題一樣會出線 dead lock 的問題</p>
<blockquote>
<ul>
<li>When replacing a block, you might move a struct buf from one bucket to another bucket, because the new block hashes to a different bucket. You might have a tricky case: the new block might hash to the same bucket as the old block. Make sure you avoid deadlock in that case.</li>
</ul></blockquote>
<p>這裡提到在 replacing 的時候 new and old 的 hash 值一樣的時候，會出現問題</p>
<p>這是上一個 hint 的特例 所以結論會是 一個 bucket 需要兩個 lock?</p>
<blockquote>
<ul>
<li>Some debugging tips: implement bucket locks but leave the global <code>bcache.lock</code> <code>acquire/release</code> at the beginning/end of <code>bget</code> to serialize the code. Once you are sure it is correct without race conditions, remove the global locks and deal with concurrency issues. You can also run <code>make CPUS=1 qemu</code> to test with one core.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Use xv6&rsquo;s race detector to find potential races (see above how to use the race detector).</li>
</ul></blockquote>
<h3 id="hash">hash<a hidden class="anchor" aria-hidden="true" href="#hash">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define NBUCKET 17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> sleeplock lock[NBUCKET];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf head[NBUCKET];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf buf[NBUF];
</span></span><span style="display:flex;"><span>} bcache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> uint
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hash</span>(uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> blockno <span style="color:#f92672">%</span> NBUCKET;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這裡之所以每個 bucket 都使用 <code>sleeplock</code> 是因為如果 miss 之後，會呼叫 <code>virtio_disk_rw()</code> 這是一個較慢的 function 使用 <code>sleeplock</code> 可以避免佔用 CPU 太久的時間</p>
<p><code>hash()</code> 則是一個簡單的把 <code>blockno</code> 轉換到 bucket 的 function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;param.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;spinlock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;sleeplock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;riscv.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;defs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;fs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;buf.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define NBUCKET 17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> sleeplock lock[NBUCKET];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf head[NBUCKET];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf buf[NBUF];
</span></span><span style="display:flex;"><span>} bcache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> uint
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hash</span>(uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> blockno <span style="color:#f92672">%</span> NBUCKET;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">binit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initsleeplock</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i], <span style="color:#e6db74">&#34;bcache&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    bcache.head[i].prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.head[i];
</span></span><span style="display:flex;"><span>    bcache.head[i].next <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.head[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf<span style="color:#f92672">+</span>NBUF; b<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.head[<span style="color:#ae81ff">0</span>].next;
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.head[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initsleeplock</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock, <span style="color:#e6db74">&#34;buffer&#34;</span>);
</span></span><span style="display:flex;"><span>    bcache.head[<span style="color:#ae81ff">0</span>].next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>    bcache.head[<span style="color:#ae81ff">0</span>].next <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Look through buffer cache for block on device dev.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If not found, allocate a buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// In either case, return locked buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>  uint i <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(blockno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start_over:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Is the block already cached?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.head[i].next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.head[i]; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno) {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Not cached, try to find local victim
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.head[i].next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.head[i]; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// need I/O
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// find victim globally 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>victim <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  uint j;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span> NBUCKET; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    j <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> k) <span style="color:#f92672">%</span> NBUCKET;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[j]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.head[j].next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.head[j]; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        victim <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (victim)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[j]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>victim)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bget: no buffer&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[j]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  uint lock1_idx, lock2_idx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>    lock1_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    lock2_idx <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    lock1_idx <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>    lock2_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock1_idx]);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock2_idx]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (victim<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock2_idx]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock1_idx]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> start_over;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.head[i].next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.head[i]; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock2_idx]);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock1_idx]);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> start_over;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// holding lock[i] and lock[j]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// actual moving
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  victim<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.head[i].next;
</span></span><span style="display:flex;"><span>  victim<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.head[i];
</span></span><span style="display:flex;"><span>  bcache.head[i].next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> victim;
</span></span><span style="display:flex;"><span>  bcache.head[i].next <span style="color:#f92672">=</span> victim;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock2_idx]);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[lock1_idx]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>victim<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> victim;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Return a locked buf with the contents of the indicated block.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bread</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> <span style="color:#a6e22e">bget</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>b<span style="color:#f92672">-&gt;</span>valid) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write b&#39;s contents to disk.  Must be locked.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bwrite</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bwrite&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Release a locked buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Move to the head of the most-recently-used list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">brelse</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;brelse&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  uint i <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wakeup</span>(b);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>  uint i <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bunpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>  uint i <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>bcache.lock[i]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="心得">心得<a hidden class="anchor" aria-hidden="true" href="#心得">#</a></h2>
<p>這個 lab 真的很需要了解 lock 的使用時機還有當前拿了哪些 lock，acqure 與 release 的順序也需要理的非常清楚才行，確實很契合了 &ldquo;Lab: locks&rdquo; 的主題</p>
<p><img alt="ac.png" loading="lazy" src="/xv6/lab8/ac.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/xv6/bcache/">
    <span class="title">« Prev</span>
    <br>
    <span>[xv6 學習紀錄 08-3] bcache 相關程式碼解析</span>
  </a>
  <a class="next" href="http://localhost:1313/dev-log/notes/">
    <span class="title">Next »</span>
    <br>
    <span>[這個網站的誕生] 筆記區域</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Yama&#39;s Trail</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
