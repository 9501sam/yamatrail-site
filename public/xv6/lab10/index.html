<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>[xv6 學習紀錄 10] Lab: mmap | Yama&#39;s Trail</title>
<meta name="keywords" content="">
<meta name="description" content="Lab 連結：Lab: mmap
Lab: mmap (hard)

The mmap and munmap system calls allow UNIX programs to exert detailed control over their address spaces. They can be used to share memory among processes, to map files into process address spaces, and as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. In this lab you&rsquo;ll add mmap and munmap to xv6, focusing on memory-mapped files.
目前的理解會像是把 memory address map 到一個 file 中，可以有多個 process share 同一份資料的好處">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/xv6/lab10/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e1f5c4cae44599655f7ff95195ff89c8cb3adbda94f2b1581a434ab2b4d4e6cf.css" integrity="sha256-4fXEyuRFmWVff/lRlf&#43;JyMs629qU8rFYGkNKsrTU5s8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon_io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon_io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon_io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon_io/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/xv6/lab10/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Yama&#39;s Trail (Alt + H)">Yama&#39;s Trail</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/dev-log/" title="這個網站的誕生">
                    <span>這個網站的誕生</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/leetcode/" title="LeetCode 解題">
                    <span>LeetCode 解題</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/xv6/" title="xv6 學習紀錄">
                    <span>xv6 學習紀錄</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/linux-kernel-programming/" title="Linux Kernel Programming">
                    <span>Linux Kernel Programming</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [xv6 學習紀錄 10] Lab: mmap
    </h1>
    <div class="post-meta"><span title='2025-11-01 12:05:39 +0800 CST'>November 1, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>Lab 連結：<a href="https://pdos.csail.mit.edu/6.S081/2022/labs/mmap.html">Lab: mmap</a></p>
<h2 id="lab-mmap-hard">Lab: mmap (hard)<a hidden class="anchor" aria-hidden="true" href="#lab-mmap-hard">#</a></h2>
<blockquote>
<p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. They can be used to share memory among processes, to map files into process address spaces, and as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. In this lab you&rsquo;ll add <code>mmap</code> and <code>munmap</code> to xv6, focusing on memory-mapped files.</p></blockquote>
<p>目前的理解會像是把 memory address map 到一個 file 中，可以有多個 process share 同一份資料的好處</p>
<blockquote>
<p>You should implement enough <code>mmap</code> and <code>munmap</code> functionality to make the <code>mmaptest</code> test program work. If <code>mmaptest</code> doesn&rsquo;t use a <code>mmap</code> feature, you don&rsquo;t need to implement that feature.</p></blockquote>
<p>這一題要我們實做出 mmap</p>
<blockquote>
<p>The manual page (run <code>man 2 mmap</code>) shows this declaration for mmap:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">size_t</span> length, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">off_t</span> offset);
</span></span></code></pre></div></blockquote>
<blockquote>
<p><code>mmap</code> can be called in many ways, but this lab requires only a subset of its features relevant to memory-mapping a file. You can assume that addr will always be zero, meaning that the kernel should decide the virtual address at which to map the file. <code>mmap</code> returns that address, or <code>0xffffffffffffffff</code> if it fails. length is the number of bytes to map; it might not be the same as the file&rsquo;s length. <code>prot</code> indicates whether the memory should be mapped readable, writeable, and/or executable; you can assume that <code>prot</code> is <code>PROT_READ</code> or <code>PROT_WRITE</code> or both. <code>flags</code> will be either <code>MAP_SHARED</code>, meaning that modifications to the mapped memory should be written back to the file, or <code>MAP_PRIVATE</code>, meaning that they should not. You don&rsquo;t have to implement any other bits in <code>flags</code>. <code>fd</code> is the open file descriptor of the file to map. You can assume <code>offset</code> is zero (it&rsquo;s the starting point in the file at which to map).</p></blockquote>
<ul>
<li>在這個 lab 的使用情境中 <code>addr</code> 永遠是 0，實際上決定 address 的地方是 kernel
<ul>
<li>原先的 <code>mmap()</code> 應該是可以指定 <code>addr</code> 的，但這裡為了簡化，所以就直接讓 kernel 決定，並且回傳 <code>addr</code></li>
</ul>
</li>
<li>return value: 回傳被 mapping 的 <code>addr</code>，如果 failed return <code>0xffffffffffffffff</code>
<ul>
<li>mapping 失敗的時候回傳 <code>0xffffffffffffffff</code></li>
</ul>
</li>
<li>length: 需要 map 的 byte 數量，可以跟 file 的 length 不一樣</li>
<li><code>prot</code> (protection): 權限，可以直接認定 <code>prot</code> 為 <code>PROT_READ</code> or <code>PROT_WRITE</code> or both
<ul>
<li><code>PROT_READ</code></li>
<li><code>PROT_WRITE</code></li>
<li><code>PROT_READ &amp; PROT_WRITE</code></li>
</ul>
</li>
<li><code>flag</code> 只有可能是以下兩者擇一
<ul>
<li><code>MAP_SHARED</code>: 修改寫回</li>
<li><code>MAP_PRIVATE</code>: 修改不寫回</li>
<li>(其實還有其他 flag 但這個 lab 不必實做)</li>
</ul>
</li>
<li><code>fd</code>: 被 mapping 的 file descriptor
<ul>
<li>在 <code>fork()</code> 的時候要使用 <code>filedup()</code> 做 copy，因為每一個 process 的 fd-&gt;file mapping 都不一樣</li>
</ul>
</li>
<li><code>offset</code>: 可以假設 <code>offset</code> 永遠為 0</li>
</ul>
<p>根據這個 hint，可以設計出 <code>struct vma</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vma {
</span></span><span style="display:flex;"><span>  uint64 addr;
</span></span><span style="display:flex;"><span>  uint64 len;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> prot;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flags;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f;
</span></span><span style="display:flex;"><span>  uint64 offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> valid;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<ul>
<li>Start by adding <code>_mmaptest</code> to <code>UPROGS</code>, and <code>mmap</code> and <code>munmap</code> system calls, in order to get <code>user/mmaptest.c</code> to compile. For now, just return errors from mmap and munmap. We defined <code>PROT_READ</code> etc for you in <code>kernel/fcntl.h</code>. Run <code>mmaptest</code>, which will fail at the first mmap call.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Fill in the page table lazily, in response to page faults. That is, <code>mmap</code> should not allocate physical memory or read the file. Instead, do that in page fault handling code in (or called by) <code>usertrap</code>, as in the lazy page allocation lab. The reason to be lazy is to ensure that <code>mmap</code> of a large file is fast, and that <code>mmap</code> of a file larger than physical memory is possible.</li>
</ul></blockquote>
<p>這裡會用到 lazy allocation 的技巧，<code>mmap</code> 只紀錄下 mapping 的關係，實際上會利用 <code>usertrap()</code> 來處理後續的動作</p>
<ul>
<li>為了更加快速</li>
<li>可以 map a file larger than physical memory</li>
</ul>
<blockquote>
<ul>
<li>Keep track of what <code>mmap</code> has mapped for each process. Define a structure corresponding to the VMA (virtual memory area) described in Lecture 15, recording the address, length, permissions, file, etc. for a virtual memory range created by mmap. Since the xv6 kernel doesn&rsquo;t have a memory allocator in the kernel, it&rsquo;s OK to declare a fixed-size array of VMAs and allocate from that array as needed. A size of 16 should be sufficient.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Implement <code>mmap</code>: find an unused region in the process&rsquo;s address space in which to map the file, and add a VMA to the process&rsquo;s table of mapped regions. The VMA should contain a pointer to a <code>struct file</code> for the file being mapped; <code>mmap</code> should increase the file&rsquo;s reference count so that the structure doesn&rsquo;t disappear when the file is closed (hint: see <code>filedup</code>). Run <code>mmaptest</code>: the first <code>mmap</code> should succeed, but the first access to the mmap-ed memory will cause a page fault and kill <code>mmaptest</code>.</li>
</ul></blockquote>
<p>這裡在說需要在 process 的 address space 中找一塊沒有用的來當作 map to the file 的區塊</p>
<ul>
<li>要使用 reference count，不然的話會讓 <code>mmaptest.c</code> 中的 <code>fork_test()</code> 無法通過
<ul>
<li>這是我自己實做的時候卡很久沒有發現的地方，因為 <code>fork()</code> 之後 child 再 <code>exit()</code> 之後，會直接把一些區塊 free 掉</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Add code to cause a page-fault in a mmap-ed region to allocate a page of physical memory, read 4096 bytes of the relevant file into that page, and map it into the user address space. Read the file with <code>readi</code>, which takes an offset argument at which to read in the file (but you will have to <code>lock/unlock</code> the inode passed to <code>readi</code>). Don&rsquo;t forget to set the permissions correctly on the page. Run mmaptest; it should get to the first <code>munmap</code>.</li>
</ul></blockquote>
<p>使用 page-fault 的策略</p>
<blockquote>
<ul>
<li>Implement <code>munmap</code>: find the VMA for the address range and <code>unmap</code> the specified pages (hint: use <code>uvmunmap</code>). If <code>munmap</code> removes all pages of a previous <code>mmap</code>, it should decrement the reference count of the corresponding struct file. If an unmapped page has been modified and the file is mapped <code>MAP_SHARED</code>, write the page back to the file. Look at <code>filewrite</code> for inspiration.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Ideally your implementation would only write back <code>MAP_SHARED</code> pages that the program actually modified. The dirty bit (D) in the RISC-V PTE indicates whether a page has been written. However, mmaptest does not check that non-dirty pages are not written back; thus you can get away with writing pages back without looking at D bits.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Modify exit to <code>unmap</code> the process&rsquo;s mapped regions as if <code>munmap</code> had been called. Run <code>mmaptest</code>; <code>mmap_test</code> should pass, but probably not <code>fork_test</code>.</li>
</ul></blockquote>
<blockquote>
<ul>
<li>Modify fork to ensure that the child has the same mapped regions as the parent. Don&rsquo;t forget to increment the reference count for a VMA&rsquo;s struct file. In the page fault handler of the child, it is OK to allocate a new physical page instead of sharing a page with the parent. The latter would be cooler, but it would require more implementation work. Run <code>mmaptest</code>; it should pass both <code>mmap_test</code> and <code>fork_test</code>.</li>
</ul></blockquote>
<p>需要先了解 <code>filedup()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Increment ref count for file f.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> file<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">filedup</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>ftable.lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(f<span style="color:#f92672">-&gt;</span>ref <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;filedup&#34;</span>);
</span></span><span style="display:flex;"><span>  f<span style="color:#f92672">-&gt;</span>ref<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>ftable.lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> f;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="解題策略">解題策略<a hidden class="anchor" aria-hidden="true" href="#解題策略">#</a></h2>
<h2 id="程式實做">程式實做<a hidden class="anchor" aria-hidden="true" href="#程式實做">#</a></h2>
<ul>
<li><code>kernel/fcntl.h</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define O_RDONLY  0x000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define O_WRONLY  0x001
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define O_RDWR    0x002
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define O_CREATE  0x200
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define O_TRUNC   0x400
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef LAB_MMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PROT_NONE       0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PROT_READ       0x1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PROT_WRITE      0x2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PROT_EXEC       0x4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAP_SHARED      0x01
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAP_PRIVATE     0x02
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><ul>
<li><code>kernel/proc.h</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MAX_VMAS 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vma {
</span></span><span style="display:flex;"><span>  uint64 addr;
</span></span><span style="display:flex;"><span>  uint64 len;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> prot;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flags;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f;
</span></span><span style="display:flex;"><span>  uint64 offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> valid;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Per-process state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> proc {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> vma vmas[MAX_VMAS];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><img alt="ac.png" loading="lazy" src="/xv6/lab10/ac.png"></p>
<h2 id="心得">心得<a hidden class="anchor" aria-hidden="true" href="#心得">#</a></h2>
<p>這個 lab 也算是個複雜的 lab，debug 時使用 Gemini 協助，但是在這個過程中也是看到了 AI 的瓶頸，曾經問 Gemini 問到它產生出心態崩潰的回應（回應「我真的受夠了」以及一直鬼打牆之類的回應XD）最後是覺得自己還是要盡可能理解背後原理的情況下 AI 才可以提供助力，不然也蠻有可能被帶離方向然後一直原地打轉，這是我做這個 lab 最大的心得。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/dev-log/notes/">
    <span class="title">« Prev</span>
    <br>
    <span>[這個網站的誕生] 筆記區域</span>
  </a>
  <a class="next" href="http://localhost:1313/xv6/lec21-networking/">
    <span class="title">Next »</span>
    <br>
    <span>[xv6 學習紀錄 11-1] Networking</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Yama&#39;s Trail</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
